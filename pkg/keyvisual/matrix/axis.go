// Copyright 2019 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

package matrix

// Axis stores consecutive buckets. Each bucket has StartKey, EndKey, and some statistics. The EndKey of each bucket is
// the StartKey of its next bucket. Therefore satisfies:
// len(Keys) == len(ValuesList) + 1.
type Axis struct {
	Keys   []string
	Values []uint64
}

// CreateAxis checks the given parameters and uses them to build the Axis.
func CreateAxis(keys []string, values []uint64) Axis {
	keysLen := len(keys)
	if keysLen <= 1 {
		panic("Keys length must be greater than 1")
	}
	if len(values) == 0 {
		panic("Values length must be greater than 0")
	}
	if keysLen != len(values)+1 {
		panic("Keys length must be equal to Values length + 1")
	}
	return Axis{
		Keys:   keys,
		Values: values,
	}
}

// CreateEmptyAxis constructs a minimal empty Axis with the given parameters.
func CreateEmptyAxis(startKey, endKey string) Axis {
	keys := []string{startKey, endKey}
	values := []uint64{0}
	return CreateAxis(keys, values)
}

// CreateZeroAxis constructs zero values Axis with the given keys
func CreateZeroAxis(keys []string) Axis {
	keysLen := len(keys)
	if keysLen <= 1 {
		panic("Keys length must be greater than 1")
	}
	return CreateAxis(keys, make([]uint64, keysLen-1))
}

// SetValues set axis.Values to values
func (axis *Axis) SetValues(values []uint64) {
	if len(values)+1 != len(axis.Keys) {
		panic("Keys length must be equal to Values length + 1")
	}
	axis.Values = values
}

// SetZeroValues set all values of axis.Values to 0
func (axis *Axis) SetZeroValues() {
	newValues := make([]uint64, len(axis.Values))
	axis.SetValues(newValues)
}

// Set all values to 0
func (axis *Axis) Clear() {
	MemsetUint64(axis.Values, 0)
}

// Range returns a sub Axis with specified range.
func (axis *Axis) Range(startKey string, endKey string) Axis {
	start, end, ok := KeysRange(axis.Keys, startKey, endKey)
	if !ok {
		return CreateEmptyAxis(startKey, endKey)
	}
	keys := axis.Keys[start:end]
	values := axis.Values[start : end-1]
	return CreateAxis(keys, values)
}

// Reduce generates new chunks based on the more sparse newKeys
func (axis *Axis) Reduce(newKeys []string) Axis {
	keys := axis.Keys
	CheckReduceOf(keys, newKeys)

	newValues := make([]uint64, len(newKeys)-1)

	if len(keys) == len(newKeys) {
		copy(newValues, axis.Values)
		return CreateAxis(newKeys, newValues)
	}

	endKeys := newKeys[1:]
	j := 0
	for i, value := range axis.Values {
		if equal(keys[i], endKeys[j]) {
			j++
		}
		newValues[j] += value
	}
	return CreateAxis(newKeys, newValues)
}

// GetFocusRows estimates the number of rows generated by executing a Focus with a specified threshold
func (axis *Axis) GetFocusRows(threshold uint64) (count int) {
	start := 0
	var bucketSum uint64 = 0
	generateBucket := func(end int) {
		if end > start {
			count++
			start = end
			bucketSum = 0
		}
	}

	for i, value := range axis.Values {
		if value >= threshold || bucketSum >= threshold {
			generateBucket(i)
		}
		bucketSum += value
	}
	generateBucket(len(axis.Values))

	return
}

// Given a `threshold`, merge the rows with less traffic,
// and merge the most `ratio` rows at a time.
// `target` is the estimated final number of rows.
func (axis *Axis) Focus(strategy Strategy, threshold uint64, ratio int, target int) Axis {
	newKeys := make([]string, 0, target)
	newValues := make([]uint64, 0, target)
	newKeys = append(newKeys, axis.Keys[0])

	start := 0
	var bucketSum uint64 = 0
	generateBucket := func(end int) {
		if end > start {
			newKeys = append(newKeys, axis.Keys[end])
			newValues = append(newValues, bucketSum)
			start = end
			bucketSum = 0
		}
	}

	for i, value := range axis.Values {
		if value >= threshold ||
			bucketSum >= threshold ||
			i-start >= ratio ||
			strategy.CrossBorder(axis.Keys[start], axis.Keys[i]) {
			generateBucket(i)
		}
		bucketSum += value
	}
	generateBucket(len(axis.Values))

	return CreateAxis(newKeys, newValues)
}

// Divide uses binary search to find a suitable threshold, which can reduce the number of buckets of Axis to near the target.
func (axis *Axis) Divide(strategy Strategy, target int) Axis {
	if target >= len(axis.Values) {
		return *axis
	}
	// get upperThreshold
	var upperThreshold uint64 = 1
	for _, value := range axis.Values {
		upperThreshold += value
	}
	// search threshold
	var lowerThreshold uint64 = 1
	targetFocusRows := target * 2 / 3 // TODO: This var can be adjusted
	for lowerThreshold < upperThreshold {
		mid := (lowerThreshold + upperThreshold) >> 1
		if axis.GetFocusRows(mid) > targetFocusRows {
			lowerThreshold = mid + 1
		} else {
			upperThreshold = mid
		}
	}

	threshold := lowerThreshold
	focusRows := axis.GetFocusRows(threshold)
	ratio := len(axis.Values)/(target-focusRows) + 1
	return axis.Focus(strategy, threshold, ratio, target)
}