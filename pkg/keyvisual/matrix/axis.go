// Copyright 2019 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

package matrix

type AxisStrategy int

const (
	SumThresholdStrategy AxisStrategy = 0
	MaxBorderStrategy    AxisStrategy = 1
	MaxGradientStrategy  AxisStrategy = 2
)

func (cs AxisStrategy) String() string {
	switch cs {
	case SumThresholdStrategy:
		return "SumThresholdStrategy"
	case MaxBorderStrategy:
		return "MaxBorderStrategy"
	case MaxGradientStrategy:
		return "MaxGradientStrategy"
	default:
		panic("unreachable")
	}
}

// Axis stores consecutive buckets. Each bucket has StartKey, EndKey, and some statistics. The EndKey of each bucket is
// the StartKey of its next bucket. Therefore satisfies:
// len(Keys) == len(ValuesList) + 1.
type Axis struct {
	Keys   []string
	Values []uint64

	Strategy AxisStrategy
}

// CreateAxis checks the given parameters and uses them to build the Axis.
func CreateAxis(keys []string, values []uint64, strategy AxisStrategy) Axis {
	keysLen := len(keys)
	if keysLen <= 1 {
		panic("Keys length must be greater than 1")
	}
	if len(values) == 0 {
		panic("Values length must be greater than 0")
	}
	if keysLen != len(values)+1 {
		panic("Keys length must be equal to Values length + 1")
	}
	return Axis{
		Keys:     keys,
		Values:   values,
		Strategy: strategy,
	}
}

// CreateEmptyAxis constructs a minimal empty Axis with the given parameters.
func CreateEmptyAxis(startKey, endKey string, strategy AxisStrategy) Axis {
	keys := []string{startKey, endKey}
	values := []uint64{0}
	return CreateAxis(keys, values, strategy)
}

// CreateZeroAxis constructs zero values Axis with the given keys
func CreateZeroAxis(keys []string, strategy AxisStrategy) Axis {
	keysLen := len(keys)
	if keysLen <= 1 {
		panic("Keys length must be greater than 1")
	}
	return CreateAxis(keys, make([]uint64, keysLen-1), strategy)
}

// SetValues set axis.Values to values
func (axis *Axis) SetValues(values []uint64) {
	if len(values)+1 != len(axis.Keys) {
		panic("Keys length must be equal to Values length + 1")
	}
	axis.Values = values
}

// SetZeroValues set all values of axis.Values to 0
func (axis *Axis) SetZeroValues() {
	newValues := make([]uint64, len(axis.Values))
	axis.SetValues(newValues)
}

// Set all values to 0
func (axis *Axis) Clear() {
	MemsetUint64(axis.Values, 0)
}

// Range returns a sub Axis with specified range.
func (axis *Axis) Range(startKey string, endKey string) Axis {
	start, end, ok := KeysRange(axis.Keys, startKey, endKey)
	if !ok {
		return CreateEmptyAxis(startKey, endKey, axis.Strategy)
	}
	keys := axis.Keys[start:end]
	values := axis.Values[start : end-1]
	return CreateAxis(keys, values, axis.Strategy)
}

// Reduce generates new chunks based on the more sparse newKeys
func (axis *Axis) Reduce(newKeys []string) Axis {
	keys := axis.Keys
	CheckReduceOf(keys, newKeys)

	newValues := make([]uint64, len(newKeys)-1)

	if len(keys) == len(newKeys) {
		copy(newValues, axis.Values)
		return CreateAxis(newKeys, newValues, axis.Strategy)
	}

	endKeys := newKeys[1:]
	j := 0
	for i, value := range axis.Values {
		if equal(keys[i], endKeys[j]) {
			j++
		}

		if axis.Strategy == SumThresholdStrategy {
			newValues[j] += value
		} else {
			newValues[j] = MaxUint64(newValues[j], value)
		}
	}
	return CreateAxis(newKeys, newValues, axis.Strategy)
}

// GetFocusRows estimates the number of rows generated by executing a Focus with a specified threshold
func (axis *Axis) GetFocusRows(threshold uint64) (count int) {
	start := 0
	var tempValue uint64 = 0
	generateBucket := func(end int) {
		if end > start {
			count++
			start = end
			tempValue = 0
		}
	}

	switch axis.Strategy {
	case SumThresholdStrategy:
		for i, value := range axis.Values {
			if value >= threshold || tempValue >= threshold {
				generateBucket(i)
			}
			tempValue += value
		}
		generateBucket(len(axis.Values))
	case MaxBorderStrategy:
		for i, value := range axis.Values {
			if value >= threshold || tempValue >= threshold {
				generateBucket(i)
			}
			tempValue = MaxUint64(tempValue, value)
		}
		generateBucket(len(axis.Values))
	case MaxGradientStrategy:
		for i, value := range axis.Values {
			if i != 0 {
				abs := AbsDifference(value, axis.Values[i-1])
				tempValue = MaxUint64(tempValue, abs)
			}
			if tempValue >= threshold {
				generateBucket(i)
			}
		}
		generateBucket(len(axis.Values))
	default:
		panic("unreachable")
	}
	return
}

// Given a `threshold`, merge the rows with less traffic,
// and merge the most `ratio` rows at a time.
// `target` is the estimated final number of rows.
func (axis *Axis) Focus(strategy Strategy, threshold uint64, ratio int, target int) Axis {
	newKeys := make([]string, 0, target)
	newValues := make([]uint64, 0, target)
	newKeys = append(newKeys, axis.Keys[0])

	start := 0
	var bucket uint64 = 0
	generateBucket := func(end int) {
		if end > start {
			newKeys = append(newKeys, axis.Keys[end])
			newValues = append(newValues, bucket)
			start = end
			bucket = 0
		}
	}
	switch axis.Strategy {
	case SumThresholdStrategy:
		for i, value := range axis.Values {
			if value >= threshold ||
				bucket >= threshold ||
				i-start >= ratio ||
				strategy.CrossBorder(axis.Keys[start], axis.Keys[i]) {
				generateBucket(i)
			}
			bucket += value
		}
		generateBucket(len(axis.Values))
	case MaxBorderStrategy:
		for i, value := range axis.Values {
			if value >= threshold ||
				bucket >= threshold ||
				i-start >= ratio ||
				strategy.CrossBorder(axis.Keys[start], axis.Keys[i]) {
				generateBucket(i)
			}
			bucket = MaxUint64(bucket, value)
		}
		generateBucket(len(axis.Values))
	case MaxGradientStrategy:
		var tempValue uint64 = 0

		for i, value := range axis.Values {
			if i != 0 {
				abs := AbsDifference(value, axis.Values[i-1])
				tempValue = MaxUint64(tempValue, abs)
			}

			if tempValue >= threshold ||
				i-start >= ratio ||
				strategy.CrossBorder(axis.Keys[start], axis.Keys[i]) {
				tempValue = 0
				generateBucket(i)
			}
			bucket = MaxUint64(bucket, value)
		}
		generateBucket(len(axis.Values))
	default:
		panic("unreachable")
	}
	return CreateAxis(newKeys, newValues, axis.Strategy)
}

// Divide uses binary search to find a suitable threshold, which can reduce the number of buckets of Axis to near the target.
func (axis *Axis) Divide(strategy Strategy, target int) Axis {
	if target >= len(axis.Values) {
		return *axis
	}
	// get upperThreshold
	var upperThreshold uint64 = 1
	switch axis.Strategy {
	case SumThresholdStrategy:
		for _, value := range axis.Values {
			upperThreshold += value
		}
	case MaxBorderStrategy, MaxGradientStrategy:
		for _, value := range axis.Values {
			upperThreshold = MaxUint64(upperThreshold, value)
		}
	default:
		panic("unreachable")
	}

	// search threshold
	var lowerThreshold uint64 = 1
	targetFocusRows := target * 2 / 3 // TODO: This var can be adjusted
	for lowerThreshold < upperThreshold {
		mid := (lowerThreshold + upperThreshold) >> 1
		if axis.GetFocusRows(mid) > targetFocusRows {
			lowerThreshold = mid + 1
		} else {
			upperThreshold = mid
		}
	}

	threshold := lowerThreshold
	focusRows := axis.GetFocusRows(threshold)
	ratio := len(axis.Values)/(target-focusRows) + 1
	return axis.Focus(strategy, threshold, ratio, target)
}
