package matrix

import "fmt"

type ChunkStrategy int

const(
	SumThresholdStrategy ChunkStrategy = 0
	MaxBorderStrategy ChunkStrategy = 1
	MaxGradientStrategy ChunkStrategy = 2
)

func (cs ChunkStrategy)String() string {
	switch cs {
	case SumThresholdStrategy:
		return "SumThresholdStrategy"
	case MaxBorderStrategy:
		return "MaxBorderStrategy"
	case MaxGradientStrategy:
		return "MaxGradientStrategy"
	default:
		panic("unreachable")
	}
}

type chunk struct {
	// Keys and ValuesList[i] from Axis
	Keys   []string
	Values []uint64

	Strategy ChunkStrategy
}

func createChunk(keys []string, values []uint64, strategy ChunkStrategy) chunk {
	keysLen := len(keys)
	if keysLen <= 1 {
		panic("Keys length must be greater than 1")
	}
	if keysLen != len(values)+1 {
		panic("Keys length must be equal to Values length + 1")
	}
	return chunk{
		Keys:   keys,
		Values: values,
		Strategy: strategy,
	}
}

func createZeroChunk(keys []string, strategy ChunkStrategy) chunk {
	keysLen := len(keys)
	if keysLen <= 1 {
		panic("Keys length must be greater than 1")
	}
	return createChunk(keys, make([]uint64, keysLen-1), strategy)
}

func (c *chunk) SetValues(values []uint64) {
	if len(values)+1 != len(c.Keys) {
		panic("Keys length must be equal to Values length + 1")
	}
	c.Values = values
}

func (c *chunk) SetZeroValues() {
	newValues := make([]uint64, len(c.Values))
	c.SetValues(newValues)
}

// Set all values to 0
func (c *chunk) Clear() {
	MemsetUint64(c.Values, 0)
}

// Calculation

// Reduce generates new chunks based on the more sparse newKeys
func (c *chunk) Reduce(newKeys []string) chunk {
	keys := c.Keys
	CheckReduceOf(keys, newKeys)

	newValues := make([]uint64, len(newKeys)-1)

	if len(keys) == len(newKeys) {
		copy(newValues, c.Values)
		return createChunk(newKeys, newValues, c.Strategy)
	}

	endKeys := newKeys[1:]
	j := 0
	for i, value := range c.Values {
		if equal(keys[i], endKeys[j]) {
			j++
		}

		if c.Strategy == SumThresholdStrategy {
			newValues[j] += value
		} else {
			newValues[j] = MaxUint64(newValues[j], value)
		}
	}
	return createChunk(newKeys, newValues, c.Strategy)
}

// GetFocusRows estimates the number of rows generated by executing a Focus with a specified threshold
func (c *chunk) GetFocusRows(threshold uint64) (count int) {
	fmt.Println("GetFocusRows:", c.Strategy.String())
	start := 0
	var tempValue uint64 = 0
	generateBucket := func(end int) {
		if end > start {
			count++
			start = end
			tempValue = 0
		}
	}

	switch c.Strategy {
	case SumThresholdStrategy:
		for i, value := range c.Values {
			if value >= threshold || tempValue >= threshold {
				generateBucket(i)
			}
			tempValue += value
		}
		generateBucket(len(c.Values))
	case MaxBorderStrategy:
		for i, value := range c.Values {
			if value >= threshold || tempValue >= threshold {
				generateBucket(i)
			}
			tempValue = MaxUint64(tempValue, value)
		}
		generateBucket(len(c.Values))
	case MaxGradientStrategy:
		for i, value := range c.Values {
			if i != 0 {
				abs := AbsDifference(value, c.Values[i-1])
				tempValue =  MaxUint64(tempValue, abs)
			}
			if tempValue >= threshold {
				generateBucket(i)
			}
		}
		generateBucket(len(c.Values))
	default:
		panic("unreachable")
	}
	return
}

// Given a `threshold`, merge the rows with less traffic,
// and merge the most `ratio` rows at a time.
// `target` is the estimated final number of rows.
func (c *chunk) Focus(strategy Strategy, threshold uint64, ratio int, target int) chunk {
	fmt.Println("Focus:", c.Strategy.String())
	newKeys := make([]string, 0, target)
	newValues := make([]uint64, 0, target)
	newKeys = append(newKeys, c.Keys[0])

	start := 0
	var bucket uint64 = 0
	generateBucket := func(end int) {
		if end > start {
			newKeys = append(newKeys, c.Keys[end])
			newValues = append(newValues, bucket)
			start = end
			bucket = 0
		}
	}
	switch c.Strategy {
	case SumThresholdStrategy:
		for i, value := range c.Values {
			if value >= threshold ||
				bucket >= threshold ||
				i-start >= ratio ||
				strategy.CrossBorder(c.Keys[start], c.Keys[i]) {
				generateBucket(i)
			}
			bucket += value
		}
		generateBucket(len(c.Values))
	case MaxBorderStrategy:
		for i, value := range c.Values {
			if value >= threshold ||
				bucket >= threshold ||
				i-start >= ratio ||
				strategy.CrossBorder(c.Keys[start], c.Keys[i]) {
				generateBucket(i)
			}
			bucket = MaxUint64(bucket, value)
		}
		generateBucket(len(c.Values))
	case MaxGradientStrategy:
		var tempValue uint64 = 0

		for i, value := range c.Values {
			if i!=0 {
				abs := AbsDifference(value, c.Values[i-1])
				tempValue =  MaxUint64(tempValue, abs)
			}

			if tempValue >= threshold ||
				i-start >= ratio ||
				strategy.CrossBorder(c.Keys[start], c.Keys[i]) {
				tempValue =  0
				generateBucket(i)
			}
			bucket = MaxUint64(bucket, value)
		}
		generateBucket(len(c.Values))
	default:
		panic("unreachable")
	}
	return createChunk(newKeys, newValues, c.Strategy)
}

// Divide uses binary search to find a suitable threshold, which can reduce the number of buckets of Axis to near the target.
func (c *chunk) Divide(strategy Strategy, target int) chunk {
	if target >= len(c.Values) {
		fmt.Println("Not Divide")
		return *c
	}
	fmt.Println("divide:", c.Strategy.String())
	// get upperThreshold
	var upperThreshold uint64 = 1
	switch c.Strategy {
	case SumThresholdStrategy:
		for _, value := range c.Values {
			upperThreshold += value
		}
	case MaxBorderStrategy, MaxGradientStrategy:
		for _, value := range c.Values {
			upperThreshold = MaxUint64(upperThreshold, value)
		}
	default:
		panic("unreachable")
	}

	// search threshold
	var lowerThreshold uint64 = 1
	targetFocusRows := target * 2 / 3 // TODO: This var can be adjusted
	for lowerThreshold < upperThreshold {
		mid := (lowerThreshold + upperThreshold) >> 1
		if c.GetFocusRows(mid) > targetFocusRows {
			lowerThreshold = mid + 1
		} else {
			upperThreshold = mid
		}
	}

	threshold := lowerThreshold
	focusRows := c.GetFocusRows(threshold)
	ratio := len(c.Values)/(target-focusRows) + 1
	return c.Focus(strategy, threshold, ratio, target)
}
